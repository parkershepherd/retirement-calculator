<html>
<head>
	<title>Retirement Calculator</title>
	<style>
		body {
			font-family: sans-serif;
		}
		h1 {
			text-align: center;
			border-bottom: solid 1px lightgrey;
			margin: 10px 20px 20px;
			padding-bottom: 10px;
		}
		h4{
			width: 180px;
			text-align: right;
			margin: 40px 0 10px 0;
		}
		label {
			width: 180px;
			display: block;
			float: left;
			text-align: right;
			padding-right: 10px;
		}
		.input-values {
			margin-bottom: 20px;
			width: 400px;
			float: left;
		}
		input {
			font-size: 16px;
			padding: 5px;
			width: 100px;
		}
		label {
			padding: 5px;
		}
		table {
			border-collapse: collapse;
		}
		table td {
			padding: 0;
		}
		.bar-container {
			min-width: 390px;
		}
		.stat {
			padding: 0 10px;
		}
		table td span {
			display: block;
			float: left;
			margin-right: 15px;
		}
		.retired {
			background-color: gold;
		}
		.saving {
			background-color: green;
		}
		.saving.waiting {
			background-color: lightgreen;
		}
		.positive {
			color: green;
		}
		.negative {
			color: darkred;
		}
	</style>
</head>
<body>
	<div class="input-values">
		<h1>Retirement Calculator</h1>

		<h4>Market Assumptions</h4>
		<label for="inflationRate">Inflation Rate</label>
		<input type="number" id="inflationRate" min="0" step="0.1" max="100"/>%
		<br/>
		<label for="earningsRate">Investment Return</label>
		<input type="number" id="earningsRate" min="0" step="0.5" max="100"/>%
		<br/>
		<label for="raiseRate">Raise Rate</label>
		<input type="number" id="raiseRate" min="0" max="100"/>%
		<br/>

		<h4>Simulation Params</h4>
		<label for="age">Age</label>
		<input type="number" id="age" min="0" max="100"/>
		<br/>
		<label for="ageAtDeath">Age at Death</label>
		<input type="number" id="ageAtDeath" min="0" max="130"/>
		<br/>
		<label for="income">Income $</label>
		<input type="number" id="income" min="0" step="5000"/>
		<br/>
		<label for="currentSavings">Current Savings $</label>
		<input type="number" id="currentSavings" min="0" step="5000"/>
		<br/>

		<h4>Lifestyle Choices</h4>
		<label for="savingsRate">Savings Rate</label>
		<input type="number" id="savingsRate" min="0" max="100"/>%
		<br/>
		<label for="retireDelayYears">Retire Delay Years</label>
		<input type="number" id="retireDelayYears" min="0"/>
		<br/>
		<label for="retirementSpending">Retirement Spending $</label>
		<input type="number" id="retirementSpending" min="0" step="5000"/>
		<br/>
	</div>
	<div id="data"></div>
	<script>
		const settingTypes = {
			inflationRate: {type: 'percent', default: 3.2},
			earningsRate: {type: 'percent', default: 6},
			raiseRate: {type: 'percent', default: 4},
			savingsRate: {type: 'percent', default: 10},
			age: {type: 'integer', default: 30},
			ageAtDeath: {type: 'integer', default: 95},
			retireDelayYears: {type: 'integer', default: 0},
			income: {type: 'currency', default: 100000},
			currentSavings: {type: 'currency', default: 10000},
			retirementSpending: {type: 'currency', default: 60000},
		}
		const settingsVersion = 2
		const localStorageKey = 'settings' + settingsVersion
		const getDom = selector => document.getElementById(selector).value
		const setDom = (selector, value) => document.getElementById(selector).value = value
		const getSettingsFromDom = () => {
			let settings = {}
			for (let settingKey in settingTypes) {
				let type = settingTypes[settingKey].type
				let def = settingTypes[settingKey].default
				let value = getDom(settingKey)
				if (value === null || value === '') {
					value = def
				}
				settings[settingKey] = type === 'percent'
					? value / 100
					: parseInt(value)
			}
			return settings
		}
		const setSettingsInDom = settings => {
			for (let settingKey in settings) {
				let settingType = settingTypes[settingKey].type
				let settingValue = settings[settingKey]
				setDom(
					settingKey,
					settingType === 'percent'
						? Math.round(settingValue * 100 * 100)/100
						: settingValue
				)
			}
		}
		const getSettingsFromLocalStorage = () => {
			let previousValues = localStorage.getItem(localStorageKey)
			return previousValues ? JSON.parse(previousValues) : null
		}
		const setSettingsInLocalStorage = settings => {
			localStorage.setItem(localStorageKey, JSON.stringify(settings))
		}
		const loadInitialSettings = () => {
			let storedSettings = getSettingsFromLocalStorage()
			if (storedSettings) {
				setSettingsInDom(storedSettings)
				return storedSettings
			}
			let values = getSettingsFromDom()
			setSettingsInLocalStorage(values)
			setSettingsInDom(values)
			return values
		}

		function simulateLife (state) {
			let years = []
			const maxIterations = state.ageAtDeath
			let iterations = 0
			let couldHaveRetiredYearsAgo = 0
			state.inflationAdjustment = 1
			state.adjustedRetirementSpending = state.retirementSpending
			state.yearlyContributions = 0
			state.yearlyWithdrawals = 0
			state.yearlyInterest = 0
			state.retired = false
			state.year = (new Date()).getFullYear()

			// Simulate non-retired years
			while (state.age <= state.ageAtDeath) {
				if (iterations > maxIterations) {
					throw new Error('Simulated too many years, something is broken')
				}
				iterations++
				state.couldHaveRetiredYearsAgo = couldHaveRetiredYearsAgo
				state.yearlyContributions = 0
				state.yearlyWithdrawals = 0
				state.yearlyInterest = 0
				state.priorSavings = state.currentSavings

				for (let month=0; month<12; month++) {
					let priorSavings = state.currentSavings
					// Assume you experience inflation throughout the year
					state.inflationAdjustment *= (1 + state.inflationRate / 12)
					state.currentSavings *= (1 + state.earningsRate / 12)
					state.yearlyInterest += state.currentSavings - priorSavings

					// Assume you don't earn interest on the current months deposits
					let depositAmount = state.income * state.savingsRate / 12
					state.yearlyContributions += depositAmount
					state.currentSavings += depositAmount
					state.adjustedRetirementSpending = state.retirementSpending * state.inflationAdjustment
				}
				years.push(Object.assign({}, state))
				// Assume you only get raises at the end of the year
				state.income *= (1 + state.raiseRate)
				state.age++
				state.year++


				// Check if we can retire yet
				const testState = Object.assign({}, state);
				testState.income = 0
				testState.retired = true
				let testIterations = 0
				let testYears = [];
				// Simulate retired years
				while (testState.age <= testState.ageAtDeath && testState.currentSavings > 0) {
					if (testIterations > maxIterations) {
						throw new Error('Simulated too many test years, something is broken')
					}
					testIterations++
					testState.yearlyContributions = 0
					testState.yearlyWithdrawals = 0
					testState.yearlyInterest = 0
					testState.priorSavings = testState.currentSavings

					for (let month=0; month<12; month++) {
						testState.inflationAdjustment *= (1 + testState.inflationRate / 12)
						testState.adjustedRetirementSpending = testState.retirementSpending * testState.inflationAdjustment
						// Assume you withdraw money at the beginning of the month
						let withdrawalAmount = testState.adjustedRetirementSpending / 12
						testState.yearlyWithdrawals += withdrawalAmount
						testState.currentSavings -= withdrawalAmount

						// Assume you earn interest at the end of the month
						let priorSavings = testState.currentSavings
						testState.currentSavings *= (1 + testState.earningsRate / 12)
						testState.yearlyInterest += testState.currentSavings - priorSavings
					}
					testYears.push(Object.assign({}, testState))
					testState.age++
					testState.year++

				}

				// Check if we were able to retire
				if (testState.age >= testState.ageAtDeath && testState.currentSavings >= 0) {

					// Check if we wanted to delay retirement
					if (testState.retireDelayYears > state.couldHaveRetiredYearsAgo) {
						couldHaveRetiredYearsAgo++
					} else {
						years = years.concat(testYears)
						state = testState
						break
					}
				}
			}
			return years
		}

		function renderLife (years) {
			const graphWidth = 300
			let firstYear = years[0]
			let lastYear = years[years.length-1]
			let yearRetired = years.find(year => year.retired)
			let maxAmount = years.reduce((max, c) => Math.max(max, c.currentSavings), 0)
			let data = document.getElementById('data')
			let fontSize = Math.min(
				18,
				Math.max(
					10,
					(document.body.clientHeight-20) / (years.length + 1) - 1
				)
			)
			let table = `
				<table style="font-size:${fontSize}px;line-height:${fontSize}px">
					<tr>
						<th>Age</th>
						<th class="bar-container">Account Value</th>
						<th class="stat">Interest</th>
						<th class="stat">In/Out</th>
						<th class="stat">Out Rate</th>
					</tr>
					${years.map(year => `
						<tr>
							<td>${year.age}</td>
							<td>
								<span class="bar ${year.retired ? 'retired' : 'saving'} ${year.couldHaveRetiredYearsAgo ? 'waiting' : ''}" style="width:${year.currentSavings * graphWidth / maxAmount}px;height:${fontSize-1}px"></span>
								<span style="height:${fontSize}px">${abbrev(year.currentSavings)}</span>
							</td>
							<td class="positive">+${abbrev(year.yearlyInterest)}</td>
							<td class="${year.yearlyContributions ? 'positive' : 'negative'}">
								${year.yearlyContributions
									? `+${abbrev(year.yearlyContributions)}`
									: `(${abbrev(year.yearlyWithdrawals)})`
							}</td>
							<td>${year.yearlyWithdrawals
								? format(year.yearlyWithdrawals * 100 / year.priorSavings,1) + '%'
								: ''
							}</td>
						</tr>
					`).join('')}
				</table>
			`
			data.innerHTML = table
		}

		// Initial render
		renderLife(simulateLife(loadInitialSettings()))


		// Set up listeners for recalculation
		let throttledRecalculate = throttle(function recalculate () {
			let start = new Date()
			let newSettings = getSettingsFromDom()
			setSettingsInLocalStorage(newSettings)
			renderLife(simulateLife(newSettings))
		}, 50)

		for (let setting in settingTypes) {
			let elem = document.getElementById(setting)
			elem.onkeyup = throttledRecalculate
			elem.onchange = throttledRecalculate
		}
		document.body.onresize = throttledRecalculate

		// Helper function
		function format (num, n, x) {
		    var re = '\\d(?=(\\d{' + (x || 3) + '})+' + (n > 0 ? '\\.' : '$') + ')'
		    return num.toFixed(Math.max(0, ~~n)).replace(new RegExp(re, 'g'), '$&,')
		}

		function abbrev(num) {
			let units = ['K', 'M', 'B', 'T']
			let iterations = 0
			while (num > 1000 && iterations < 4) {
				num /= 1000
				iterations++
			}
			let bigDigits = num > 100 ? 3 : (num > 10 ? 2 : 1)
			let unit = iterations > 0 ? units[iterations-1] : ''
			return '$' + format(num, 3-bigDigits) + unit
		}

		function throttle(callback, ms) {
			let lastRun
			let lastRequest
			return function throttled() {
				let args = arguments
				lastRequest = new Date().getTime()
				if (!lastRun || lastRequest - lastRun  > ms) {
					lastRun = lastRequest
					callback.apply(null, args)
				} else {
					setTimeout(() => {
						if (new Date().getTime() - lastRun > ms) {
							lastRun = lastRequest
							callback.apply(null, args)
						}
					}, ms)
				}
			}
		}

	</script>
</body>
</html>